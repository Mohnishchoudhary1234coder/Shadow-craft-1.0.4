<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Voxel Game ‚Äî Creative Mode (128x128)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <style>
    html,body { height:100%; margin:0; background:#111; overflow:hidden; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; -webkit-user-select:none; user-select:none; touch-action:none; }
    #hud {
      position:fixed; left:12px; top:12px; z-index:60;
      background:rgba(0,0,0,0.45); color:#fff; padding:10px 12px; border-radius:8px;
      font-family: monospace; font-size:13px; max-width:46%;
    }
    #hint {
      position:fixed; left:50%; transform:translateX(-50%); bottom:14px; z-index:50;
      color:#fff; background:rgba(0,0,0,0.35); padding:8px 12px; border-radius:8px; font-size:13px;
    }

    /* Controls & Hotbar */
    #controls-ui {
      position:fixed; left:0; right:0; bottom:0; display:flex; justify-content:space-between; padding:12px;
      z-index:45; pointer-events:none;
    }
    #joy-left { width:140px; height:140px; margin-left:12px; pointer-events:auto; touch-action:none; position:relative; }
    .joy-bg { width:100%; height:100%; background:rgba(255,255,255,0.04); border-radius:50%; border:1px solid rgba(255,255,255,0.08); display:flex; align-items:center; justify-content:center; }
    .joy-knob { width:48px; height:48px; background:rgba(255,255,255,0.14); border-radius:50%; transform:translate(-50%,-50%); position:absolute; left:50%; top:50%; pointer-events:none; display:flex; align-items:center; justify-content:center; color:#fff; font-size:14px; }

    #right-controls { margin-right:12px; display:flex; flex-direction:column; gap:10px; pointer-events:none; align-items:flex-end; }
    #look-area { width:220px; height:140px; background:rgba(255,255,255,0.03); border-radius:12px; touch-action:none; pointer-events:auto; position:relative; border:1px solid rgba(255,255,255,0.06); }
    .action-row { display:flex; gap:10px; margin-top:6px; pointer-events:auto; }
    .btn { width:56px; height:56px; background:rgba(255,255,255,0.06); border-radius:12px; border:1px solid rgba(255,255,255,0.12); color:#fff; font-size:20px; display:flex; align-items:center; justify-content:center; user-select:none; touch-action:manipulation; }

    /* Hotbar with textured icons (Updated for more slots) */
    #hotbar {
      position:fixed; left:50%; transform:translateX(-50%); bottom:84px; z-index:55;
      display:flex; gap:6px; /* Reduced gap slightly to fit more */
      pointer-events:none;
      max-width: 95%; /* Allow it to take up more space */
      overflow-x: auto; /* Allow scrolling if it gets too wide */
    }
    .hotbar-slot {
      pointer-events:auto;
      width:60px; height:60px; /* Slight size reduction to fit more blocks */
      min-width: 60px; /* Ensure they don't shrink */
      background:rgba(0,0,0,0.6); border-radius:8px;
      border:2px solid rgba(255,255,255,0.08); display:flex; flex-direction:column; align-items:center; justify-content:center;
      color:#fff; font-size:12px; cursor:pointer;
      box-sizing:border-box;
    }
    .hotbar-slot .icon {
      width:32px; height:32px; border-radius:6px; margin-bottom:4px; background-size:cover; background-position:center;
      box-shadow: inset 0 -6px 12px rgba(0,0,0,0.25);
    }
    .hotbar-slot .count { font-size:11px; opacity:0.9; }
    .hotbar-slot.selected { border-color: #ffd36b; box-shadow: 0 0 12px rgba(255,211,107,0.18); transform:translateY(-4px); }

    #progress { position:fixed; left:50%; transform:translateX(-50%); bottom:156px; z-index:68; width:260px; height:14px; background:rgba(255,255,255,0.06); border-radius:8px; overflow:hidden; display:none }
    #progress > div { height:100%; width:0%; background:linear-gradient(90deg,#ffd36b,#ff8a3d); border-radius:8px }

    @media (pointer: fine) { #controls-ui { display:none; } }
    @media (max-width:420px) { 
        #look-area { width:160px; height:120px } 
        #joy-left { width:110px; height:110px } 
        .hotbar-slot { width:48px; height:48px; min-width: 48px; } 
        .hotbar-slot .icon { width:28px; height:28px; }
    }

    canvas { display:block; }
  </style>
  <div id="crosshair" style="position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); font-size:32px; color:rgba(255,255,255,0.85); z-index:100; pointer-events:none;">+</div>
</head>
<body>
  <div id="hud">Loading...</div>
  <div id="hint">Click to lock pointer (desktop). WASD move, Space jump, Q break, E place. Mobile: left joystick move, right drag look.</div>

  <div id="controls-ui" aria-hidden="true">
    <div id="joy-left" aria-hidden="true"><div class="joy-bg"></div><div class="joy-knob" id="joy-knob">‚Ä¢</div></div>

    <div id="right-controls" aria-hidden="true">
      <div id="look-area" title="Drag here to look (mobile)"></div>
      <div class="action-row">
        <div class="btn" id="btn-break">‚õè</div>
        <div class="btn" id="btn-jump">‚§¥</div>
        <div class="btn" id="btn-place">üß±</div>
      </div>
    </div>
  </div>

  <div id="hotbar"></div>
  <div id="progress"><div></div></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';

    // ======= Config Updates: Creative Mode & World Size =======
    const CREATIVE_MODE = true;
    const WORLD_W = 128, WORLD_H = 36, WORLD_D = 128; // Doubled size for bigger land
    const PLAYER_EYE = 1.6;
    const JOY_DEADZONE = 0.18, MAX_JOY = 48;
    const BLOCK_AIR = 0;

    // Player Bounding Box Constants
    const PLAYER_W = 0.35; // Half-width/depth of the player (0.7 wide/deep total)
    const PLAYER_H = 1.8;  // Total height of the player
    
    // Block metadata (Expanded for Creative Mode)
    const BLOCKS = {
      1: { name: 'Dirt', color: 0x6c5b38, hardness: 0.6 },
      2: { name: 'Stone', color: 0x8b8b8b, hardness: 1.4 },
      3: { name: 'Grass', color: 0x3ea033, hardness: 0.7 },
      4: { name: 'Wood', color: 0x8b5a2b, hardness: 1.0 },
      5: { name: 'Leaves', color: 0x4ca04c, hardness: 0.3, transparent: true },
      6: { name: 'Sand', color: 0xe4d99b, hardness: 0.5 },
      7: { name: 'Brick', color: 0xa84f3e, hardness: 1.5 },
      8: { name: 'Glass', color: 0xeeeeee, hardness: 0.1, transparent: true },
      9: { name: 'Gold', color: 0xffd700, hardness: 3.0 },
      10: { name: 'Lapis', color: 0x3c64a4, hardness: 2.5 },
      11: { name: 'Obsidian', color: 0x221a30, hardness: 5.0 },
      12: { name: 'Water', color: 0x47789a, hardness: 0.0, transparent: true, liquid: true },
    };

    // Inventory is ignored in Creative Mode
    const inventory = {}; 
    let selectedBlockId = 1;

    let allowPlacing = true; 

    // ---------- Utils ----------
    function idx(x,y,z,w,d){ return x + w*(z + d*y); }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function inBounds(x,y,z){ return x>=0 && y>=0 && z>=0 && x<WORLD_W && y<WORLD_H && z<WORLD_D; }

    // ---------- Texture generation (procedural canvas textures) ----------
    const textureCanvases = {}; // id -> canvas
    function makeBlockCanvas(colorHex, opts = {}) {
      const size = 64;
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      // base
      ctx.fillStyle = '#' + colorHex.toString(16).padStart(6,'0');
      ctx.fillRect(0,0,size,size);
      // light & dark gradients for shading
      const g = ctx.createLinearGradient(0,0,size,size);
      g.addColorStop(0, 'rgba(255,255,255,0.06)');
      g.addColorStop(1, 'rgba(0,0,0,0.06)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,size,size);
      // add subtle noise
      const img = ctx.getImageData(0,0,size,size);
      for(let i=0;i<img.data.length;i+=4){
        const v = (Math.random()*30 - 15) | 0;
        img.data[i] = clamp(img.data[i]+v,0,255);
        img.data[i+1] = clamp(img.data[i+1]+v,0,255);
        img.data[i+2] = clamp(img.data[i+2]+v,0,255);
      }
      ctx.putImageData(img,0,0);
      // optional pattern
      if(opts.type === 'wood'){
        ctx.strokeStyle = 'rgba(0,0,0,0.06)';
        ctx.lineWidth = 2;
        for(let i=8;i<size;i+=8){
          ctx.beginPath(); ctx.ellipse(size/2, size/2, i, i*0.6, 0, 0, Math.PI*2); ctx.stroke();
        }
      } else if(opts.type === 'leaves'){
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        for(let i=0;i<40;i++){
          ctx.fillRect(Math.random()*size, Math.random()*size, Math.random()*6+1, Math.random()*6+1);
        }
      } else if(opts.type === 'sand'){
        ctx.fillStyle = 'rgba(0,0,0,0.04)';
        for(let i=0;i<120;i++){
          ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1);
        }
      } else if(opts.type === 'brick'){
        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        ctx.lineWidth = 1;
        for(let i=0; i<size; i+=8) ctx.strokeRect(0, i, size, 4);
        for(let i=0; i<size; i+=16) ctx.strokeRect(i, 0, 8, size);
        for(let i=8; i<size; i+=16) ctx.strokeRect(i, 4, 8, size);
      } else if(opts.type === 'glass'){
         ctx.fillStyle = 'rgba(255,255,255,0.1)';
         ctx.fillRect(0,0,size,size);
         ctx.strokeStyle = 'rgba(0,0,0,0.08)';
         ctx.lineWidth = 2;
         ctx.strokeRect(size/4, size/4, size/2, size/2);
      }
      return c;
    }

    const materialCache = {};
    function getMaterialForBlock(id){
      if(materialCache[id]) return materialCache[id];
      const meta = BLOCKS[id];
      const canvas = textureCanvases[id] || (textureCanvases[id] = makeBlockCanvas(meta.color, { type: meta.name.toLowerCase() }));
      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      
      const isTransparent = meta.transparent || false;
      
      const mat = new THREE.MeshLambertMaterial({ 
          map: tex, 
          transparent: isTransparent, 
          opacity: isTransparent ? (meta.liquid ? 0.6 : 0.8) : 1.0, // Water is slightly more transparent
          side: THREE.DoubleSide // Important for transparent blocks
      });

      materialCache[id] = { material: mat, textureCanvas: canvas };
      return materialCache[id];
    }

    // ---------- VoxelWorld (group of per-type InstancedMesh for textured blocks) ----------
    class VoxelWorld {
      constructor(w,h,d, scene) {
        this.w = w; this.h = h; this.d = d;
        this.size = w*h*d;
        this.blocks = new Uint8Array(this.size).fill(0);
        this.instanceIdToCoord = [];
        this.group = new THREE.Group();
        this._meshes = {};
        this._counts = {};
        if(scene) scene.add(this.group);
        this.generateTerrainAndTrees();
        this.updateMeshes();
      }

      generateTerrainAndTrees() {
        for(let x=0;x<this.w;++x){
          for(let z=0;z<this.d;++z){
            const ridge = Math.sin(x*0.14) * Math.cos(z*0.09);
            const hill = Math.floor(5 + 6 * (0.5 + 0.5*ridge) + 3*Math.sin((x+z)*0.06));
            let h = clamp(hill + Math.floor(2*Math.random()), 1, this.h-4);
            const distEdge = Math.min(x, z, this.w-1-x, this.d-1-z);
            if(distEdge < 4) h = Math.max(1, Math.floor(2 + Math.random()*1.5));
            for(let y=0;y<h;++y){
              if(distEdge < 4) this.set(x,y,z, 6);
              else if(y < h-2) this.set(x,y,z, 2);
              else if(y < h-1) this.set(x,y,z, 1);
              else this.set(x,y,z, 3);
            }
            // small tree
            if(h > 3 && Math.random() < 0.04 && distEdge >= 6){ // Slightly more trees for bigger map
              const trunkH = 3 + Math.floor(Math.random()*2);
              for(let ty = h; ty < Math.min(h+trunkH, this.h-1); ++ty) this.set(x,ty,z, 4);
              const ly = Math.min(h+trunkH, this.h-2);
              for(let ix=-2; ix<=2; ix++) for(let iz=-2; iz<=2; iz++) for(let iy=0; iy<=1; iy++){
                const lx = x+ix, lz = z+iz, lypos = ly+iy;
                if(this.inBounds(lx,lypos,lz) && Math.abs(ix)+Math.abs(iz) <= 4 && this.get(lx,lypos,lz) === BLOCK_AIR) this.set(lx,lypos,lz, 5);
              }
            }
            
            // Add some water near low points
            if (h < 6 && distEdge > 8 && Math.random() < 0.005) {
                // Creates a small water pool at height 5
                for(let poolY = 1; poolY < 6; poolY++) {
                    if(this.get(x, poolY, z) === BLOCK_AIR) this.set(x, poolY, z, 12); 
                }
            }
          }
        }
      }

      inBounds(x,y,z){ return x>=0 && y>=0 && z>=0 && x<this.w && y<this.h && z<this.d; }
      get(x,y,z){ if(!this.inBounds(x,y,z)) return BLOCK_AIR; return this.blocks[idx(x,y,z,this.w,this.d)]; }
      set(x,y,z,val){ if(!this.inBounds(x,y,z)) return; this.blocks[idx(x,y,z,this.w,this.d)] = val; }

      updateMeshes(){
        // remove old
        while(this.group.children.length) {
          const c = this.group.children.pop();
          if(c.geometry) c.geometry.dispose();
          if(c.material) c.material.dispose();
        }
        this._meshes = {};
        this._counts = {};

        // collect per-type lists
        const lists = {};
        for(let x=0;x<this.w;x++) for(let y=0;y<this.h;y++) for(let z=0;z<this.d;z++){
          const bid = this.get(x,y,z);
          if(bid && bid !== BLOCK_AIR){
            (lists[bid] = lists[bid] || []).push({x,y,z});
          }
        }

        const tmp = new THREE.Matrix4();
        const boxGeom = new THREE.BoxGeometry(1,1,1);
        Object.keys(lists).forEach(k=>{
          const id = parseInt(k);
          const arr = lists[k];
          const matInfo = getMaterialForBlock(id);
          const inst = new THREE.InstancedMesh(boxGeom, matInfo.material, arr.length);
          inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
          for(let i=0;i<arr.length;i++){
            tmp.makeTranslation(arr[i].x + 0.5, arr[i].y + 0.5, arr[i].z + 0.5);
            inst.setMatrixAt(i, tmp);
          }
          inst.count = arr.length;
          inst.userData.blockId = id;
          this.group.add(inst);
          this._meshes[id] = inst;
          this._counts[id] = arr.length;
        });
        boxGeom.dispose();
      }
    }

    // ---------- Input & UI ----------
    const inputState = { fw:0, bk:0, lt:0, rt:0, run:false, jump:false, place:false, break:false, pointerLocked:false };
    const joystick = { active:false, id:null, startX:0, startY:0, dx:0, dy:0 };

    const hud = document.getElementById('hud');
    const hotbarEl = document.getElementById('hotbar');
    const progressBar = document.getElementById('progress');
    const progressFill = progressBar.querySelector('div');

    function rebuildHotbarUI(){
      hotbarEl.innerHTML = '';
      // In Creative Mode, display all defined blocks
      const keys = Object.keys(BLOCKS).map(x=>parseInt(x)).filter(id => id > 0);
      
      for(const id of keys){
        const slot = document.createElement('div');
        slot.className = 'hotbar-slot' + (id === selectedBlockId ? ' selected' : '');
        slot.dataset.bid = id;
        const matInfo = getMaterialForBlock(id);
        const canvas = matInfo.textureCanvas;
        const dataURL = canvas.toDataURL();
        
        // Creative Mode: Count is always infinity symbol
        const countDisplay = CREATIVE_MODE ? '‚àû' : (inventory[id] ?? 0); 

        slot.innerHTML = `<div class="icon" style="background-image:url('${dataURL}');"></div>
                          <div class="count">${countDisplay}</div>`;
        slot.title = BLOCKS[id].name;
        slot.addEventListener('click', ()=>{
          selectedBlockId = id;
          rebuildHotbarUI();
        });
        slot.addEventListener('touchstart', (e)=>{ e.preventDefault(); selectedBlockId = id; rebuildHotbarUI(); }, {passive:false});
        hotbarEl.appendChild(slot);
      }
      document.getElementById('hint').innerText = 'WASD move, Space jump, Q break, E place. Select blocks with 1-' + keys.length + '. Mobile: left joystick move, right drag look.';
    }

    // ---------- Controls setup and mobile UI ----------
    function setupControls(player, camera){
      // pointer lock
      document.addEventListener('click', ()=>{ if(window.matchMedia && window.matchMedia('(pointer: fine)').matches) document.body.requestPointerLock?.(); });
      document.addEventListener('pointerlockchange', ()=> {
        inputState.pointerLocked = (document.pointerLockElement === document.body);
        if(inputState.pointerLocked) window.addEventListener('mousemove', onMouseMove);
        else window.removeEventListener('mousemove', onMouseMove);
      });
      function onMouseMove(e){
        player.yaw   -= e.movementX * 0.0025;
        player.pitch -= e.movementY * 0.0025;
        player.pitch = clamp(player.pitch, -Math.PI/2 + 0.01, Math.PI/2 - 0.01);
      }

      window.addEventListener('keydown', e=>{
        if(e.code === 'KeyW') inputState.fw = 1;
        if(e.code === 'KeyS') inputState.bk = 1;
        if(e.code === 'KeyA') inputState.lt = 1;
        if(e.code === 'KeyD') inputState.rt = 1;
        if(e.code === 'ShiftLeft' || e.code === 'ShiftRight') inputState.run = true;
        if(e.code === 'Space') inputState.jump = true;
        if(e.code === 'KeyE') inputState.place = true;
        if(e.code === 'KeyQ') inputState.break = true;
        
        if(e.key >= '1' && e.key <= '9'){
          const n = parseInt(e.key);
          const keys = Object.keys(BLOCKS).map(x=>parseInt(x)).filter(id => id > 0);
          if(n-1 < keys.length){ selectedBlockId = keys[n-1]; rebuildHotbarUI(); }
        }
      });
      window.addEventListener('keyup', e=>{
        if(e.code === 'KeyW') inputState.fw = 0;
        if(e.code === 'KeyS') inputState.bk = 0;
        if(e.code === 'KeyA') inputState.lt = 0;
        if(e.code === 'KeyD') inputState.rt = 0;
        if(e.code === 'ShiftLeft' || e.code === 'ShiftRight') inputState.run = false;
        if(e.code === 'Space') inputState.jump = false;
        if(e.code === 'KeyE') inputState.place = false;
        if(e.code === 'KeyQ') inputState.break = false;
      });

      // mobile joystick
      const joyLeft = document.getElementById('joy-left');
      const joyKnob = document.getElementById('joy-knob');
      if(joyLeft){
        joyLeft.addEventListener('touchstart', (e)=>{ e.preventDefault(); const t = e.changedTouches[0]; joystick.active = true; joystick.id = t.identifier; const rect = joyLeft.getBoundingClientRect(); joystick.startX = rect.left + rect.width/2; joystick.startY = rect.top + rect.height/2; joystick.dx = joystick.dy = 0; updateKnob(); }, {passive:false});
        joyLeft.addEventListener('touchmove', (e)=>{ if(!joystick.active) return; for(const t of Array.from(e.changedTouches)){ if(t.identifier===joystick.id){ joystick.dx = t.clientX - joystick.startX; joystick.dy = t.clientY - joystick.startY; const dist = Math.hypot(joystick.dx, joystick.dy); if(dist > MAX_JOY){ const s = MAX_JOY / dist; joystick.dx *= s; joystick.dy *= s; } updateKnob(); e.preventDefault(); return; } } }, {passive:false});
        joyLeft.addEventListener('touchend', (e)=>{ for(const t of Array.from(e.changedTouches)){ if(t.identifier===joystick.id){ joystick.active=false; joystick.id=null; joystick.dx=joystick.dy=0; updateKnob(); e.preventDefault(); return; } } }, {passive:false});
      }
      function updateKnob(){ if(!joyKnob || !joyLeft) return; const w = joyLeft.clientWidth, h = joyLeft.clientHeight; joyKnob.style.left = (50 + joystick.dx / w * 100) + '%'; joyKnob.style.top  = (50 + joystick.dy / h * 100) + '%'; }
      window._mobileJoystick = joystick;
      // look area drag on mobile
      const lookArea = document.getElementById('look-area');
      let lookTouchId = null, lastLookX = 0, lastLookY = 0;
      if(lookArea){
        lookArea.addEventListener('touchstart', (e)=>{ const t = e.changedTouches[0]; lookTouchId = t.identifier; lastLookX = t.clientX; lastLookY = t.clientY; }, {passive:true});
        lookArea.addEventListener('touchmove', (e)=>{ if(lookTouchId === null) return; for(const t of Array.from(e.changedTouches)){ if(t.identifier===lookTouchId){ const dx = t.clientX - lastLookX, dy = t.clientY - lastLookY; player.yaw -= dx * 0.0035; player.pitch -= dy * 0.0035; player.pitch = clamp(player.pitch, -Math.PI/2 + 0.01, Math.PI/2 - 0.01); lastLookX = t.clientX; lastLookY = t.clientY; e.preventDefault(); return; } } }, {passive:false});
        lookArea.addEventListener('touchend', (e)=>{ for(const t of Array.from(e.changedTouches)){ if(t.identifier===lookTouchId){ lookTouchId=null; e.preventDefault(); return; } } }, {passive:false});
      }

      // on-screen action buttons
      const btnPlace = document.getElementById('btn-place'), btnBreak = document.getElementById('btn-break'), btnJump = document.getElementById('btn-jump');
      if(btnPlace){ btnPlace.addEventListener('touchstart', e=>{ e.preventDefault(); inputState.place = true; }, {passive:false}); btnPlace.addEventListener('touchend', e=>{ inputState.place = false; }, {passive:true}); }
      if(btnBreak){ btnBreak.addEventListener('touchstart', e=>{ e.preventDefault(); inputState.break = true; }, {passive:false}); btnBreak.addEventListener('touchend', e=>{ inputState.break = false; }, {passive:true}); }
      if(btnJump){ btnJump.addEventListener('touchstart', e=>{ e.preventDefault(); inputState.jump = true; }, {passive:false}); btnJump.addEventListener('touchend', e=>{ inputState.jump = false; }, {passive:true}); }
    }

    // ---------- Three.js setup ----------
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const sun = new THREE.DirectionalLight(0xffffff, 0.9);
    sun.position.set(10,30,10);
    scene.add(sun);

    // ---------- World & meshes ----------
    const world = new VoxelWorld(WORLD_W, WORLD_H, WORLD_D, scene);

    // ---------- Player ----------
    const player = {
      pos: new THREE.Vector3(Math.floor(WORLD_W/2)+0.5, 20 + PLAYER_EYE, Math.floor(WORLD_D/2)+0.5), 
      velocity: new THREE.Vector3(),
      yaw: 0, pitch: 0,
      speed: 4.0, jumpVel: 6.0, onGround: false
    };

    setupControls(player, camera);

    // Raycast helper (center)
    const raycaster = new THREE.Raycaster();
    function getBlockTarget(){
      camera.updateMatrixWorld();
      raycaster.setFromCamera({x:0,y:0}, camera);
      const origin = raycaster.ray.origin.clone();
      const dir = raycaster.ray.direction.clone();
      const step = 0.12, maxDist = 8;
      const p = origin.clone();
      for(let t=0;t<maxDist;t+=step){
        p.addScaledVector(dir, step);
        const bx = Math.floor(p.x), by = Math.floor(p.y), bz = Math.floor(p.z);
        if(!inBounds(bx,by,bz)) continue;
        const bid = world.get(bx,by,bz);
        if(bid && bid !== BLOCK_AIR){
          const prev = p.clone().addScaledVector(dir, -step);
          const tx = Math.floor(prev.x), ty = Math.floor(prev.y), tz = Math.floor(prev.z);
          return { block:{x:bx,y:by,z:bz,id:bid}, place:{x:tx,y:ty,z:tz} };
        }
      }
      return null;
    }

    // ---------- Collision helper (FIXED for AABB) ----------
    function collidesAt(pos){
      const points = [
        // Bottom layer points
        {dx: -PLAYER_W, dy: -PLAYER_H + 0.05, dz: -PLAYER_W},
        {dx: -PLAYER_W, dy: -PLAYER_H + 0.05, dz:  PLAYER_W},
        {dx:  PLAYER_W, dy: -PLAYER_H + 0.05, dz: -PLAYER_W},
        {dx:  PLAYER_W, dy: -PLAYER_H + 0.05, dz:  PLAYER_W},
        // Top layer points (near the top of the body)
        {dx: -PLAYER_W, dy: -0.1, dz: -PLAYER_W},
        {dx: -PLAYER_W, dy: -0.1, dz:  PLAYER_W},
        {dx:  PLAYER_W, dy: -0.1, dz: -PLAYER_W},
        {dx:  PLAYER_W, dy: -0.1, dz:  PLAYER_W},
      ];

      for (const {dx, dy, dz} of points) {
        const checkX = Math.floor(pos.x + dx);
        const checkY = Math.floor(pos.y + dy);
        const checkZ = Math.floor(pos.z + dz);
        if (world.get(checkX, checkY, checkZ) !== BLOCK_AIR) {
          // Check for liquid blocks (Water: 12) - allow movement
          if (world.get(checkX, checkY, checkZ) !== 12) {
            return true; // Solid block collision detected
          }
        }
      }
      return false;
    }
    
    function wouldOverlapPlayer(tx,ty,tz, ppos){
      const half = PLAYER_W;
      const pmin = {x:ppos.x-half, y:ppos.y-PLAYER_H+0.1, z:ppos.z-half};
      const pmax = {x:ppos.x+half, y:ppos.y+0.01, z:ppos.z+half};
      const bmin = {x:tx, y:ty, z:tz}, bmax = {x:tx+1, y:ty+1, z:tz+1};
      return (pmin.x < bmax.x && pmax.x > bmin.x) && (pmin.y < bmax.y && pmax.y > bmin.y) && (pmin.z < bmax.z && pmax.z > bmin.z);
    }

    // ---------- Mining/placing state ----------
    let lastTime = performance.now();
    let placeTimer = 0, breakTimer = 0;
    const COOLDOWN_MS = 180;
    
    function animate(now){
      const dt = Math.min((now - lastTime)/1000, 0.05);
      lastTime = now;
      placeTimer = Math.max(0, placeTimer - dt*1000);
      breakTimer = Math.max(0, breakTimer - dt*1000);

      // Movement (joystick + keyboard)
      const js = window._mobileJoystick || {active:false, dx:0, dy:0};
      let joyX = 0, joyY = 0;
      if(js.active){ joyX = js.dx / MAX_JOY; joyY = -js.dy / MAX_JOY; if(Math.abs(joyX) < JOY_DEADZONE) joyX = 0; if(Math.abs(joyY) < JOY_DEADZONE) joyY = 0; }
      const kbForward = inputState.fw ? 1 : (inputState.bk ? -1 : 0);
      const kbStrafe  = inputState.rt ? 1 : (inputState.lt ? -1 : 0);
      const forward = joyY !== 0 ? joyY : kbForward;
      const strafe  = joyX !== 0 ? joyX : kbStrafe;
      const speed = player.speed * (inputState.run ? 1.8 : 1.0);
      const sinY = Math.sin(player.yaw), cosY = Math.cos(player.yaw);
      let mvx = 0, mvz = 0;
      if(Math.abs(forward) > 0 || Math.abs(strafe) > 0){
        mvx = (strafe) * cosY + (forward) * sinY;
        mvz = (strafe) * -sinY + (forward) * cosY;
        const len = Math.hypot(mvx,mvz) || 1; mvx = (mvx / len) * speed; mvz = (mvz / len) * speed;
      }
      player.velocity.x = mvx; player.velocity.z = mvz;
      player.velocity.y -= 12.0 * dt; // Gravity

      // Check for ground collision before jumping
      const foot = player.pos.clone(); foot.y -= 0.2;
      player.onGround = collidesAt(foot);
      
      // If player is on the ground and moving down, stop vertical movement
      if(player.onGround && player.velocity.y < 0) player.velocity.y = 0;
      if(player.onGround && inputState.jump){ player.velocity.y = player.jumpVel; player.onGround = false; }


      // --- Movement Integration ---
      let next = player.pos.clone();

      // 1. Move X
      next.x += player.velocity.x * dt;
      if (collidesAt(new THREE.Vector3(next.x, player.pos.y, player.pos.z))) {
        player.velocity.x = 0;
        if (player.pos.x < next.x) player.pos.x = Math.floor(next.x + PLAYER_W) - PLAYER_W - 0.001; // positive X
        else player.pos.x = Math.ceil(next.x - PLAYER_W) + PLAYER_W + 0.001; // negative X
      } else {
        player.pos.x = next.x;
      }

      // 2. Move Y
      next.y += player.velocity.y * dt;
      if (collidesAt(new THREE.Vector3(player.pos.x, next.y, player.pos.z))) {
        if (player.velocity.y < 0) { // Hitting ground
          player.onGround = true;
          player.pos.y = Math.floor(next.y - PLAYER_H) + PLAYER_H + 0.001; 
        } else { // Hitting head
          player.pos.y = Math.floor(next.y - 0.1) - 0.001; 
        }
        player.velocity.y = 0;
      } else {
        player.pos.y = next.y;
      }

      // 3. Move Z
      next.z += player.velocity.z * dt;
      if (collidesAt(new THREE.Vector3(player.pos.x, player.pos.y, next.z))) {
        player.velocity.z = 0;
        if (player.pos.z < next.z) player.pos.z = Math.floor(next.z + PLAYER_W) - PLAYER_W - 0.001; // positive Z
        else player.pos.z = Math.ceil(next.z - PLAYER_W) + PLAYER_W + 0.001; // negative Z
      } else {
        player.pos.z = next.z;
      }
      // --- End Movement Integration ---


      // camera follow
      const eye = player.pos.clone();
      if(eye.y < PLAYER_EYE) eye.y = PLAYER_EYE;
      camera.position.set(eye.x, eye.y, eye.z);
      const lookDir = new THREE.Vector3(Math.sin(player.yaw) * Math.cos(player.pitch), Math.sin(player.pitch), Math.cos(player.yaw) * Math.cos(player.pitch));
      camera.lookAt(eye.clone().add(lookDir));

      // targeting & UI
      const tgt = getBlockTarget();
      const cross = document.getElementById('crosshair');
      if(cross) cross.style.color = tgt ? '#ffd36b' : 'rgba(255,255,255,0.85)';

      // breaking (Creative Mode: just remove block)
      if(inputState.break && breakTimer <= 0 && tgt){
        const bx = tgt.block.x, by = tgt.block.y, bz = tgt.block.z;
        const bid = tgt.block.id;
        if(bid && bid !== BLOCK_AIR){
          world.set(bx,by,bz, BLOCK_AIR);
          // inventory change removed for creative mode
          world.updateMeshes();
          rebuildHotbarUI();
          breakTimer = COOLDOWN_MS;
        }
        inputState.break = false;
      }

      // placing (Creative Mode: no inventory check/decrease)
      if(inputState.place && placeTimer <= 0 && tgt){
        const tx = tgt.place.x, ty = tgt.place.y, tz = tgt.place.z;
        // Check if the placing block is within bounds, is air, and doesn't overlap the player
        if(inBounds(tx,ty,tz) && world.get(tx,ty,tz) === BLOCK_AIR && !wouldOverlapPlayer(tx,ty,tz, player.pos)) {
          
          // Creative Mode: always place if a block is selected
          if(selectedBlockId > 0){ 
            world.set(tx,ty,tz, selectedBlockId);
            // inventory change removed for creative mode
            world.updateMeshes();
            rebuildHotbarUI();
            placeTimer = COOLDOWN_MS;
          }
        }
        inputState.place = false;
      }

      // sun rotation
      const nowt = performance.now() * 0.00012;
      sun.position.set(50*Math.sin(nowt), 50*Math.cos(nowt), 20*Math.cos(nowt*0.7));

      // HUD
      const numBlocks = Object.keys(BLOCKS).length;
      hud.innerHTML = `<span style="color:#ffd36b;">[CREATIVE MODE]</span><br>` +
                      `World Size: ${WORLD_W}x${WORLD_D}<br>` +
                      `Pos: ${player.pos.x.toFixed(2)}, ${player.pos.y.toFixed(2)}, ${player.pos.z.toFixed(2)}<br>` +
                      `Selected: ${BLOCKS[selectedBlockId].name}<br>` +
                      `Controls: WASD move, Space jump, Q break, E place, 1-${numBlocks} select`;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    
    // Handle window resize
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onWindowResize);

    // initialize
    rebuildHotbarUI();
    requestAnimationFrame(animate);
    camera.position.set(player.pos.x, player.pos.y, player.pos.z);
    camera.lookAt(player.pos.x + Math.sin(player.yaw), player.pos.y + Math.sin(player.pitch), player.pos.z + Math.cos(player.yaw));
    document.getElementById('hud').innerText = "Loaded. Click to lock pointer (desktop). Mobile controls available. Q to break, E to place. 128x128 World.";
  </script>
</body>
</html>
